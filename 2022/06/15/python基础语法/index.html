
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>python基础语法 - Hexo</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="Python基础数据类型整数
二进制数只使用数字0、1表示，在Python中，二进制整数使用前缀0b表示，比如：0b0110，0b1100。
十六进制数除了0~9十个数字以外，还使用a、b、c、d、,"> 
    <meta name="author" content="FOW"> 
    <link rel="alternative" href="atom.xml" title="Hexo" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
    
    
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:title" content="python基础语法 - Hexo"/>
    <meta name="twitter:description" content="Python基础数据类型整数
二进制数只使用数字0、1表示，在Python中，二进制整数使用前缀0b表示，比如：0b0110，0b1100。
十六进制数除了0~9十个数字以外，还使用a、b、c、d、,"/>
    
    
    
    
    <meta property="og:site_name" content="Hexo"/>
    <meta property="og:type" content="object"/>
    <meta property="og:title" content="python基础语法 - Hexo"/>
    <meta property="og:description" content="Python基础数据类型整数
二进制数只使用数字0、1表示，在Python中，二进制整数使用前缀0b表示，比如：0b0110，0b1100。
十六进制数除了0~9十个数字以外，还使用a、b、c、d、,"/>
    
<link rel="stylesheet" href="/css/diaspora.css">

<meta name="generator" content="Hexo 6.3.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">Hexo</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://example.com"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">python基础语法</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">python基础语法</h1>
        <div class="stuff">
            <span>六月 15, 2022</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/python/" rel="tag">python</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" rel="tag">编程语言</a></li></ul>


        </div>
        <div class="content markdown">
            <h3 id="Python基础数据类型"><a href="#Python基础数据类型" class="headerlink" title="Python基础数据类型"></a><strong>Python基础数据类型</strong></h3><p><strong>整数</strong></p>
<p>二进制数只使用数字0、1表示，在Python中，二进制整数使用前缀<strong>0b</strong>表示，比如：0b0110，0b1100。</p>
<p>十六进制数除了0~9十个数字以外，还使用a、b、c、d、e、f，在Python中，十六进制使用前缀<strong>0x</strong>，比如：0x12ef，0xde2431af。</p>
<p><strong>浮点数</strong></p>
<p>为什么小数在计算机领域被称为浮点数呢？这是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的（浮动的），比如，1.23x10^9和12.3x10^8是相等的，因此称为浮点数。</p>
<p>浮点数可以用数学写法，如1.23，3.14，-9.01。但是对于很大或很小的浮点数，就必须用科学计数法表示，在Python中，把10用e替代，比如：1.23x10^9就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5</p>
<p>这里有必要提醒一点就是，整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的，而浮点数运算则可能会有四舍五入的误差，如何检验，可以在Python终端中输入以下内容0.1 + 0.2，看看可以得到你期望的结果0.3吗？真实结果可能让你失望了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt;0.1+0.2</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;0.30000000000000004</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>字符串</strong></p>
<p>在Python中，字符串是以’’或””括起来的任意文本，比如’abc’，”xyz”等等。</p>
<p><strong>布尔值</strong></p>
<p>一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写，不需要使用字符串符号括起来）</p>
<p><strong>空值</strong></p>
<p>空值是Python里一个特殊的值，用<strong>None</strong>表示。</p>
<h3 id="Python定义变量的方法"><a href="#Python定义变量的方法" class="headerlink" title="Python定义变量的方法"></a>Python定义变量的方法</h3><ol>
<li>变量名由大小写英文字母、数字和下划线_组成</li>
<li>变量不能用数字开头</li>
<li>变量尽量不要和Python关键字重合（比如前面学习过的：and、or、not，否则可能导致Python原有关键字发挥不出作用）</li>
</ol>
<p>以下这些变量的定义都是合法的。</p>
<p>num, count, _none, min_value<br>他们都满足上面的三个条件。</p>
<p>以下这些变量的定义都是不合法的。</p>
<p>1num, 666, 1_cd, and</p>
<p><strong>定义变量</strong></p>
<p>在Python里面，一个变量可以先后存储多种不同类型的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = 1 # 这个时候a存储的是整数类型</span><br><span class="line">print(a)</span><br><span class="line">a = &#x27;ABC&#x27; # 这个时候a存储的是字符串类型</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>

<p>这是Python这类语言特有的特性，我们称之为<strong>动态语言</strong>，与之对应的是静态语言，Python、Javascript等等都是动态语言，Java、C、C++等等属于静态语言。</p>
<h3 id="Python的整数与浮点数"><a href="#Python的整数与浮点数" class="headerlink" title="Python的整数与浮点数"></a>Python的整数与浮点数</h3><p><strong>四则运算</strong></p>
<p>整数、浮点数可以直接进行四则运算。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 加法</span><br><span class="line">num1 = 10</span><br><span class="line">num2 = 0.5</span><br><span class="line">result = num1 + num2</span><br><span class="line">print(result) # ==&gt; 10.5</span><br><span class="line"># 减法</span><br><span class="line">result = num1 - num2</span><br><span class="line">print(result) # ==&gt; 9.5</span><br><span class="line"># 乘法</span><br><span class="line">result = num1 * num2</span><br><span class="line">print(result) # ==&gt; 5.0</span><br><span class="line"># 除法</span><br><span class="line">result = num1 / num2</span><br><span class="line">print(result) # ==&gt;20.0</span><br></pre></td></tr></table></figure>
<p>从上面可以发现一个规律，整数和浮点数运算后 ，得到的结果不管小数点后是否有值，结果都变成浮点数了，这是合理的，浮点数可以表达整数的结果，但是整数不能表达浮点数的结果。</p>
<p><strong>注意：在Python2使用除法可能和Python3得到不一样的结果</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># python2</span><br><span class="line">num1 = 10</span><br><span class="line">num2 = 3</span><br><span class="line">result = num1 / num2</span><br><span class="line">print(result) # ==&gt; 3</span><br><span class="line"># python3</span><br><span class="line">num1 = 10</span><br><span class="line">num2 = 3</span><br><span class="line">result = num1 / num2</span><br><span class="line">print(result) # ==&gt; 3.3333333333333335</span><br></pre></td></tr></table></figure>
<p>可以看到在python2，得到的是一个整数的结果，这是因为除数和被除数都是整数时，得到的结果也默认保存为整数了，这是非常不科学的，因此在python3，改进了这一点。</p>
<p><strong>地板除</strong></p>
<p>Python除了普通除法以外，还有一个特殊的除法被称为地板除，对于地板除，得到的结果会忽略纯小数的部分，得到整数的部分，地板除使用&#x2F;&#x2F;进行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10//4 # ==&gt; 2</span><br><span class="line">10//2.5 # ==&gt; 4.0</span><br><span class="line">10//3 # ==&gt; 3</span><br></pre></td></tr></table></figure>

<p><strong>小数点位数</strong></p>
<p>使用Python计算小数的时候，经常需要保留小数点后若干位，可以使用round()函数来处理，这里先了解round的调用方式，使用两个参数，第一个是需要保留小数点位数的数值，第二个是保留的位数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num = 10 / 3</span><br><span class="line">print(num) # ==&gt; 3.3333333333333335</span><br><span class="line"># 使用round保留两位小数</span><br><span class="line">round(num, 2) # ==&gt; 3.33</span><br></pre></td></tr></table></figure>
<h3 id="Python的布尔类型"><a href="#Python的布尔类型" class="headerlink" title="Python的布尔类型"></a>Python的布尔类型</h3><p><strong>需要注意的是，not计算的优先级是高于and和or的。</strong></p>
<p><strong>短路计算</strong></p>
<ol>
<li>在计算a and b时，如果 a 是 False，则根据与运算法则，整个结果必定为 False，因此返回 a；如果 a 是 True，则整个计算结果必定取决与 b，因此返回 b。</li>
<li>在计算a or b时，如果 a 是 True，则根据或运算法则，整个计算结果必定为 True，因此返回 a；如果 a 是 False，则整个计算结果必定取决于 b，因此返回 b。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/FOWnglp/FOWnglp.github.io/master/img/python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A61.png" alt="逻辑运算符"></p>
<p><img src="https://raw.githubusercontent.com/FOWnglp/FOWnglp.github.io/master/img/python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A62.png" alt="逻辑运算符2"><br><a target="_blank" rel="noopener" href="https://docs.python.org/3/reference/expressions.html#boolean-operations"><strong>参考文献</strong></a> <a target="_blank" rel="noopener" href="https://docs.python.org/3/reference/expressions.html#boolean-operations">https://docs.python.org/3/reference/expressions.html#boolean-operations</a></p>
<h3 id="python字符串"><a href="#python字符串" class="headerlink" title="python字符串"></a>python字符串</h3><p>Python字符串用<code>\</code>进行转义</p>
<p>要表示字符串Bob said “I’m OK”<br>由于’和”会引起歧义，因此，我们在它前面插入一个\表示这是一个普通字符，不代表字符串的起始，因此，这个字符串又可以表示为</p>
<p><code>&#39;Bob said \&quot;I\&#39;m OK\&quot;.&#39;</code></p>
<p>注意：转义字符 \不计入字符串的内容中。</p>
<p>常用的转义字符还有：</p>
<ul>
<li>\n表示换行</li>
<li>\t 表示一个制表符</li>
<li>\表示 \ 字符本身</li>
</ul>
<p><strong>Python中raw字符串与多行字符串</strong></p>
<p>如果一个字符串包含很多需要转义的字符，对每一个字符都进行转义会很麻烦。为了避免这种情况，我们可以在字符串前面加个前缀r，表示这是一个 raw 字符串，里面的字符就不需要转义了。例如：</p>
<p><code>r&#39;\(~_~)/ \(~_~)/&#39;</code></p>
<p>但是<code>r&#39;...&#39;</code>表示法不能表示多行字符串，也不能表示包含’和 “的字符串。</p>
<p>如果要表示多行字符串，可以用<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>表示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x27;&#x27;&#x27;Line 1</span><br><span class="line">Line 2</span><br><span class="line">Line 3&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>

<p>上面这个字符串的表示方法和下面的是完全一样的：</p>
<p><code>&#39;Line 1\nLine 2\nLine 3&#39;</code></p>
<p>还可以在多行字符串前面添加r，把这个多行字符串也变成一个raw字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r&#x27;&#x27;&#x27;Python is created by &quot;Guido&quot;.</span><br><span class="line">It is free and easy to learn.</span><br><span class="line">Let&#x27;s start learn Python in imooc!&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="Python的字符串format"><a href="#Python的字符串format" class="headerlink" title="Python的字符串format"></a>Python的字符串format</h3><p>字符串是Python程序重要的数据类型，到目前为止，我们输出的字符串的内容都是固定的，但有时候通过字符串输出的内容不是固定的，这个时候需要使用format来处理字符串，输出不固定的内容。</p>
<p>字符串format由两个部分组成，字符串模板和模板数据内容组成，通过大括号{}，就可以把模板数据内容嵌到字符串模板对应的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 字符串模板</span><br><span class="line">template = &#x27;Hello &#123;&#125;&#x27;</span><br><span class="line"># 模板数据内容</span><br><span class="line">world = &#x27;World&#x27;</span><br><span class="line">result = template.format(world)</span><br><span class="line">print(result) # ==&gt; Hello World</span><br></pre></td></tr></table></figure>
<p>如果模板中{}比较多，则容易错乱，那么在format的时候也可以指定模板数据内容的顺序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 指定顺序</span><br><span class="line">template = &#x27;Hello &#123;0&#125;, Hello &#123;1&#125;, Hello &#123;2&#125;, Hello &#123;3&#125;.&#x27;</span><br><span class="line">result = template.format(&#x27;World&#x27;, &#x27;China&#x27;, &#x27;Beijing&#x27;, &#x27;imooc&#x27;)</span><br><span class="line">print(result) # ==&gt; Hello World, Hello China, Hello Beijing, Hello imooc.</span><br><span class="line"># 调整顺序</span><br><span class="line">template = &#x27;Hello &#123;3&#125;, Hello &#123;2&#125;, Hello &#123;1&#125;, Hello &#123;0&#125;.&#x27;</span><br><span class="line">result = template.format(&#x27;World&#x27;, &#x27;China&#x27;, &#x27;Beijing&#x27;, &#x27;imooc&#x27;)</span><br><span class="line">print(result) # ==&gt; Hello imooc, Hello Beijing, Hello China, Hello World.</span><br></pre></td></tr></table></figure>
<p>除了使用顺序，还可以指定对应的名字，使得在format过程更加清晰。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 指定&#123;&#125;的名字w,c,b,i</span><br><span class="line">template = &#x27;Hello &#123;w&#125;, Hello &#123;c&#125;, Hello &#123;b&#125;, Hello &#123;i&#125;.&#x27;</span><br><span class="line">world = &#x27;World&#x27;</span><br><span class="line">china = &#x27;China&#x27;</span><br><span class="line">beijing = &#x27;Beijing&#x27;</span><br><span class="line">imooc = &#x27;imooc&#x27;</span><br><span class="line"># 指定名字对应的模板数据内容</span><br><span class="line">result = template.format(w = world, c = china, b = beijing, i = imooc)</span><br><span class="line">print(result) # ==&gt; Hello World, Hello China, Hello Beijing, Hello imooc.</span><br></pre></td></tr></table></figure>

<p><strong>Python的字符串切片</strong></p>
<p>有时候，我们会想获取字符串的一部分（子串），这个时候我们采取切片的方式获取，切片需要在中括号[]中填入两个数字，中间用冒号分开，表示子串的开始位置和结束位置，并且这是半闭半开区间，不包括最后的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = &#x27;ABCDEFGHIJK&#x27;</span><br><span class="line">abcd = s[0:4] # 取字符串s中的第一个字符到第五个字符，不包括第五个字符</span><br><span class="line">print(abcd) # ==&gt; ABCD</span><br><span class="line">cdef = s[2:6] # 取字符串s中的第三个字符到第七个字符，不包括第七个字符</span><br><span class="line">print(cdef) # ==&gt; CDEF</span><br></pre></td></tr></table></figure>
<h3 id="Python之if语句"><a href="#Python之if语句" class="headerlink" title="Python之if语句"></a>Python之if语句</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">score = 59</span><br><span class="line">if score &lt; 60:</span><br><span class="line">    print(&#x27;抱歉，考试不及格&#x27;)</span><br><span class="line"># ==&gt; 抱歉，考试不及格</span><br></pre></td></tr></table></figure>

<p>这里，因为<code>score = 59 &lt; 60</code>，所以if的判断是True，因此就会执行<code>print(&#39;抱歉，考试不及格&#39;)</code>。</p>
<p>这里有几个需要注意的地方：</p>
<ol>
<li>可以看到print(‘抱歉，考试不及格’)这行代码明显比上一行代码缩进了，这是因为这行代码是if判断的一个子分支，因此需要缩进，在Python规范中，一般使用4个空格作为缩进</li>
<li>在if语句的最后，有一个冒号:，这是条件分支判断的格式，在最后加入冒号:，表示接下来是分支代码块<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">score = 59</span><br><span class="line">if score &lt; 60:</span><br><span class="line">    print(&#x27;抱歉，考试不及格&#x27;)</span><br><span class="line">else:</span><br><span class="line">    print(&#x27;恭喜你，考试及格&#x27;)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这个时候，程序就会根据score的值，走不同的子逻辑分支，同学可以改变score的值试一试。</p>
<p>在这里，同样需要注意两个地方，第一个是冒号:，在else中，同样需要冒号；其次是缩进，在else的子逻辑分支，同样需要缩进。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">score = 59</span><br><span class="line">if score &lt; 60:</span><br><span class="line">    print(&#x27;抱歉，考试不及格&#x27;)</span><br><span class="line">elif score &gt;= 90:</span><br><span class="line">    print(&#x27;恭喜你，拿到卓越的成绩&#x27;)</span><br><span class="line">elif score &gt;= 80:</span><br><span class="line">    print(&#x27;恭喜你，拿到优秀的成绩&#x27;)</span><br><span class="line">else:</span><br><span class="line">    print(&#x27;恭喜你，考试及格&#x27;)</span><br></pre></td></tr></table></figure>
<h3 id="Python之for循环"><a href="#Python之for循环" class="headerlink" title="Python之for循环"></a>Python之for循环</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &#x27;ABCD&#x27;</span><br><span class="line">for ch in s:</span><br><span class="line">    print(ch) # 注意缩进</span><br></pre></td></tr></table></figure>
<p>在上述代码中，ch是在for循环中定义的，意思是把字符串s中的每一个元素依次赋值给ch，然后再把ch打印出来，直到打印出字符串s的最后一个字符为止。</p>
<h3 id="什么是容器、什么是list"><a href="#什么是容器、什么是list" class="headerlink" title="什么是容器、什么是list"></a>什么是容器、什么是list</h3><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><p>生活中，容器指的是可以容纳物品的收纳器，在程序中，容器是一种可以把多个元素放在一起的数据结构，容器中的元素可以逐个地迭代获取，可以用in, not in等关键字判断某个元素是否包含在容器中。</p>
<p>在Python中，包括列表(list)、元组(tuple)、字典(dict)、集合(set)等，他们都可以放入多个元素，因此都可以算作是容器，这些容器是Python编程中非常重要的数据结构，我们接下来重点学习这些数据结构。</p>
<h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>列表(list)是一种有序的容器，放入list中的元素，将会按照一定顺序排列。构造list的方法非常简单，使用中括号[]把需要放在容器里面的元素括起来，就定义了一个列表。<br>比如列出所有同学们的成绩：</p>
<p><code>scores = [45, 60, 75, 86, 49, 100]</code></p>
<p>列出所有同学们的名字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">names = [&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;David&#x27;, &#x27;Ellena&#x27;] </span><br><span class="line"># 注意，字符串元素仍需要引号</span><br></pre></td></tr></table></figure>
<p>正如我们看到的，list可以放入数字、字符串等数据类型，list不对放入其中的类型进行判断，也就是说，list可以同时放入任意类型的数据，这是Python这门语言决定的，因为Python是动态语言。</p>
<p><code>L = [&#39;Alice&#39;, 66, &#39;Bob&#39;, True, &#39;False&#39;, 100]</code></p>
<p>对于list，我们可以直接把list的内容打印出来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">L = [&#x27;Alice&#x27;, 66, &#x27;Bob&#x27;, True, &#x27;False&#x27;, 100]</span><br><span class="line">print(L)</span><br></pre></td></tr></table></figure>

<h3 id="Python按顺序访问list"><a href="#Python按顺序访问list" class="headerlink" title="Python按顺序访问list"></a>Python按顺序访问list</h3><p>列表是有序的，因此我们可以按顺序访问列表中的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">L = [&#x27;Alice&#x27;, 66, &#x27;Bob&#x27;, True, &#x27;False&#x27;, 100]</span><br><span class="line">for item in L:</span><br><span class="line">    print(item)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>回想一下，在前面，我们学习过字符串，这里使用for循环访问列表中的每一个元素和使用for循环访问字符串中的每一个字符是非常类似的。</p>
<p>事实上字符串也可以看作是一种特殊的列表，它只能按顺序存放多个字符。通过for循环访问列表每一个元素的方式，我们称为迭代。<br>而对于一个空的列表，使用for循环访问，将不会打印任何东西。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L = []</span><br><span class="line">for item in L:</span><br><span class="line">    print(item)</span><br></pre></td></tr></table></figure>

<h3 id="Python按索引访问list"><a href="#Python按索引访问list" class="headerlink" title="Python按索引访问list"></a>Python按索引访问list</h3><p>由于列表list是一个有序的容器，所以在list里面，每一个元素都有一个唯一的位置，我们称之为索引(index)，这和字符串是类似的，因此我们也可以通过位置的方式获取list中的元素，回顾一下前面学习的，我们通过中括号[]来按位置访问对应的元素。</p>
<p><strong>注意，这里要注意区分，列表的定义也是通过中括号[]来定义的，但这和通过索引访问列表里面的元素并不冲突</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">names = [&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;David&#x27;, &#x27;Ellena&#x27;]</span><br><span class="line">print(names[0])</span><br><span class="line">print(names[1])</span><br><span class="line">print(names[2])</span><br><span class="line">print(names[3])</span><br></pre></td></tr></table></figure>
<p>由于names只有四个元素，所以我们最多只能通过索引3访问到最后一个元素。试想一下，如果我们print(names[4])，会怎么样？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">names = [&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;David&#x27;, &#x27;Ellena&#x27;]</span><br><span class="line">print(names[4])</span><br></pre></td></tr></table></figure>
<p>事实上，这会引起Python运行的错误，提示索引访问超出范围。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">IndexError: list index out of range</span><br></pre></td></tr></table></figure>
<p>因此，我们在使用索引的方式访问列表时，一定要特别注意不要越界。<br>同时，列表和字符串一样，也支持切片，通过切片的方式，获取到列表的子列表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">names = [&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;David&#x27;, &#x27;Ellena&#x27;]</span><br><span class="line">sub_names = names[0:2]</span><br><span class="line">print(sub_names)</span><br></pre></td></tr></table></figure>
<p>这里需要注意一下，如果我们越界切片的话，不会出现Python运行错误，但是按照这样的下标去切片，获取不到任何元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">names = [&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;David&#x27;, &#x27;Ellena&#x27;]</span><br><span class="line">sub_names = names[5:10]</span><br><span class="line">print(sub_names) # ==&gt; []</span><br></pre></td></tr></table></figure>
<h3 id="Python倒序访问list"><a href="#Python倒序访问list" class="headerlink" title="Python倒序访问list"></a>Python倒序访问list</h3><p>Python的列表，除了支持正向顺序索引获取列表中的每一个元素以外，也支持倒序访问list中的每一个元素。</p>
<p><code>names = [&#39;Alice&#39;, &#39;Bob&#39;, &#39;David&#39;, &#39;Ellena&#39;]</code></p>
<p>对于names列表，Ellena的名字排在最后，也就是我们所说的倒数第一个，在Python中，可以使用-1来表示最后一个元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">names = [&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;David&#x27;, &#x27;Ellena&#x27;]</span><br><span class="line">print(names[-1]) # ==&gt; Ellena</span><br></pre></td></tr></table></figure>
<p>同样的道理，我们可以通过-2，打印出David的名字，通过-3，打印出Bob的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(names[-2]) # ==&gt; David</span><br><span class="line">print(names[-3]) # ==&gt; Bob</span><br></pre></td></tr></table></figure>
<p><strong>注意，如果我们使用-5的话，因为不存在倒数第五个名字，因此这也是一种越界，同样会报错。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">names = [&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;David&#x27;, &#x27;Ellena&#x27;]</span><br><span class="line">print(names[-5])</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">IndexError: list index out of range</span><br></pre></td></tr></table></figure>

<h3 id="Python向list添加新的元素"><a href="#Python向list添加新的元素" class="headerlink" title="Python向list添加新的元素"></a>Python向list添加新的元素</h3><p>现在班里面有4名同学：</p>
<blockquote>
<p>names &#x3D; [‘Alice’, ‘Bob’, ‘David’, ‘Ellena’]</p>
</blockquote>
<p>今天，班里转来一名新同学Candy，如何把新同学添加到现有的列表当中呢？</p>
<p>在Python中，list提供了一系列的方法可以让我们操作list中的元素，其中也包含了添加元素的方法。</p>
<p><strong>第一个办法是用append()方法，把新同学追加到列表的末尾：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">names = [&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;David&#x27;, &#x27;Ellena&#x27;]</span><br><span class="line">names.append(&#x27;Candy&#x27;)</span><br><span class="line">print(names) # ==&gt; [&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;David&#x27;, &#x27;Ellena&#x27;, &#x27;Candy&#x27;]</span><br></pre></td></tr></table></figure>
<p><strong>注意，append()方法总是将元素添加到list的尾部。</strong></p>
<p>如果上面的列表需要按照首字母排序的话，那么Candy应该是排在第三的位置的，这怎么办呢？</p>
<p>这就需要使用list的<strong>insert()方法</strong>，insert()方法和append()方法不一样，insert()方法需要两个参数，分别是需要插入的位置，以及需要插入的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">names = [&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;David&#x27;, &#x27;Ellena&#x27;]</span><br><span class="line">names.insert(2, &#x27;Candy&#x27;)</span><br><span class="line">print(names) # ==&gt; [&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;Candy&#x27;, &#x27;David&#x27;, &#x27;Ellena&#x27;]</span><br></pre></td></tr></table></figure>
<p><strong>注意，将Candy插入到第三的位置之后，原来的名字，都将自动往后移动一位，这个时候再使用相同的索引获取后面的元素，将会得到不一样的结果</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">names = [&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;David&#x27;, &#x27;Ellena&#x27;]</span><br><span class="line">print(names[2]) # ==&gt; David</span><br><span class="line">names.insert(2, &#x27;Candy&#x27;)</span><br><span class="line">print(names[2]) # ==&gt;Candy</span><br></pre></td></tr></table></figure>
<h3 id="Python从list删除元素"><a href="#Python从list删除元素" class="headerlink" title="Python从list删除元素"></a>Python从list删除元素</h3><p>如果Ellena因为家庭原因需要转学，那么我们如何把Ellena从已有的列表里面删除呢？</p>
<p>这个时候我们可以使用列表的pop()方法，pop()方法默认删除列表的最后一个元素，并返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">L = [&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;Candy&#x27;, &#x27;David&#x27;, &#x27;Ellena&#x27;]</span><br><span class="line">name = L.pop()</span><br><span class="line">print(name) # ==&gt; Ellena</span><br><span class="line">print(L) # ==&gt; L = [&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;Candy&#x27;, &#x27;David&#x27;]</span><br></pre></td></tr></table></figure>
<p>对于Ellena，由于Ellena恰好位于列表的最后，所以可以直接使用pop()方法把Ellena从列表的最后删除，假如需要转学的不是Ellena，而是Candy，这个时候应该怎么办呢？</p>
<p>pop()方法，除了可以删除最后一个元素以外，pop()还可以接收一个参数，指定需要删除的元素的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">L = [&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;Candy&#x27;, &#x27;David&#x27;, &#x27;Ellena&#x27;]</span><br><span class="line">name = L.pop(2)</span><br><span class="line">print(name) # ==&gt; Candy</span><br><span class="line">print(L) # ==&gt; [&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;David&#x27;, &#x27;Ellena&#x27;]</span><br></pre></td></tr></table></figure>
<h3 id="Python替换list中的元素"><a href="#Python替换list中的元素" class="headerlink" title="Python替换list中的元素"></a>Python替换list中的元素</h3><p>对于列表，除了可以向列表添加元素，删除列表元素以外，列表已有的元素，也是可以修改的，通过索引指定位置，并赋值新的元素，即可替换列表中原有的元素。</p>
<p>假如班上同学Candy需要转走了，同时有一个新的同学Canlina转入，那么按照字母排序，Canlina的位置恰好是Candy的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L = [&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;Candy&#x27;, &#x27;David&#x27;, &#x27;Ellena&#x27;]</span><br><span class="line">L[2] = &#x27;Canlina&#x27;</span><br><span class="line">print(L)</span><br></pre></td></tr></table></figure>
<p>我们也可以使用倒序索引来完成同样的功能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L = [&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;Candy&#x27;, &#x27;David&#x27;, &#x27;Ellena&#x27;]</span><br><span class="line">L[-3] = &#x27;Canlina&#x27;</span><br><span class="line">print(L)</span><br></pre></td></tr></table></figure>
<p>注意，如果替换一个不存在的下标，则同样会引起Python运行错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">L = [&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;Candy&#x27;, &#x27;David&#x27;, &#x27;Ellena&#x27;]</span><br><span class="line">L[6] = &#x27;Canlina&#x27;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">IndexError: list assignment index out of range</span><br></pre></td></tr></table></figure>
<h3 id="Python二维list"><a href="#Python二维list" class="headerlink" title="Python二维list"></a>Python二维list</h3><p>有时候，一维list并不能满足所有的要求（上述所有list均为一维list），这个时候需要二维list甚至更高维的list。</p>
<p>比如：</p>
<blockquote>
<p>Alice最近的三次成绩分别是[100, 89, 92]<br>Bob最近的三次成绩分别是[70, 65, 81]<br>Candy最近的三次成绩分别是[88, 72, 77]<br>如果需要用一个列表存放三个同学的成绩，则需要这样：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alice_scores = [100, 89, 92]</span><br><span class="line">bob_scores = [70, 65, 81]</span><br><span class="line">candy_scores = [88, 72, 77]</span><br><span class="line">all_scores = [alice_scores, bob_scores, candy_scores]</span><br><span class="line">print(all_scores) # ==&gt; [[100, 89, 92], [70, 65, 81], [88, 72, 77]]</span><br></pre></td></tr></table></figure>
<p>这个时候得到的就是一个二维list，对于二维list，列表里面的每一个元素仍然是一个列表。这个时候，如果需要从二维list </p>
<p>all_scores获取Bob最近第三次考试的成绩，可以这样写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alice_scores = [100,89,92]</span><br><span class="line">bob_scores = [70,65,81]</span><br><span class="line">candy_scores = [88,72,77]</span><br><span class="line">all_scores = [alice_scores, bob_scores, candy_scores]</span><br><span class="line">score = all_scores[1][2] # ==&gt; 81</span><br></pre></td></tr></table></figure>
<p>其中all_scores[1]得到Bob的最近三次成绩的列表，再通过下标[2]，则可以得到Bob第三次的成绩。</p>
<h3 id="什么是tuple"><a href="#什么是tuple" class="headerlink" title="什么是tuple"></a>什么是tuple</h3><p>元组(tuple)和list一样，也是一个有序容器，在元组中，同样可以包含0个或者多个元素，并且也支持索引访问、切片等操作。<br>定义元组的方式是使用小括号()将元组内的元素括起来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">T = (&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;Candy&#x27;, &#x27;David&#x27;, &#x27;Ellena&#x27;)</span><br><span class="line"># 通过下标的方式访问元素</span><br><span class="line">print(T[0]) # ==&gt; Alice</span><br><span class="line">print(T[4]) # ==&gt; Ellena</span><br><span class="line"># 切片</span><br><span class="line">print(T[1:3]) # ==&gt; (&#x27;Bob&#x27;, &#x27;Candy&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>元组数据类型可以把不是元组的容器转换为元组，比如将列表转换成元组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">L = [&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;Candy&#x27;, &#x27;David&#x27;, &#x27;Ellena&#x27;]</span><br><span class="line">print(L) # ==&gt; [&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;Candy&#x27;, &#x27;David&#x27;, &#x27;Ellena&#x27;]</span><br><span class="line">T = tuple(L)</span><br><span class="line">print(T) # ==&gt; (&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;Candy&#x27;, &#x27;David&#x27;, &#x27;Ellena&#x27;)</span><br></pre></td></tr></table></figure>
<p>同样的，对于列表数据类型，也可以把元组转换成列表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T = (&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;Candy&#x27;, &#x27;David&#x27;, &#x27;Ellena&#x27;)</span><br><span class="line">print(T) # ==&gt; (&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;Candy&#x27;, &#x27;David&#x27;, &#x27;Ellena&#x27;)</span><br><span class="line">L = list(T)</span><br><span class="line">print(L) # ==&gt; [&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;Candy&#x27;, &#x27;David&#x27;, &#x27;Ellena&#x27;]</span><br></pre></td></tr></table></figure>
<p>但是，tuple和list不一样的是，tuple是固定不变的，一旦变成tuple，tuple中的每一个元素都不可被改变，同时也不能再往tuple中添加数据，而list是可以的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">T = (&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;Candy&#x27;, &#x27;David&#x27;, &#x27;Ellena&#x27;)</span><br><span class="line"># 替换元素</span><br><span class="line">T[1] = &#x27;Boby&#x27;</span><br><span class="line"># 报错</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: &#x27;tuple&#x27; object does not support item assignment</span><br></pre></td></tr></table></figure>
<p><strong>请注意，元组(tuple)的这个特性是非常重要的，在运行上tuple的性能是list的数倍。</strong></p>
<h3 id="访问tuple元素的其他方法"><a href="#访问tuple元素的其他方法" class="headerlink" title="访问tuple元素的其他方法"></a>访问tuple元素的其他方法</h3><p>由于tuple一旦定义之后便不可修改，所以在实际编程中，tuple经常用于存放固定不变的数据。</p>
<p>因此在使用上，tuple提供了便捷的方法可以访问tuple中的数据。</p>
<h4 id="count-方法"><a href="#count-方法" class="headerlink" title="count()方法"></a>count()方法</h4><p>count()方法用来统计tuple中某个元素出现的次数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T = (1, 1, 2, 2, 3, 3, 1, 3, 5, 7, 9)</span><br><span class="line">print(T.count(1)) # ==&gt; 3</span><br><span class="line">print(T.count(5)) # ==&gt; 1</span><br></pre></td></tr></table></figure>
<p>对于不存在的元素，count方法不会报错，而是返回0，这是合理的，因为元组里面有0个不存在的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T = (1, 1, 2, 2, 3, 3, 1, 3, 5, 7, 9)</span><br><span class="line">print(T.count(10)) # ==&gt; 0</span><br></pre></td></tr></table></figure>
<h4 id="index-方法"><a href="#index-方法" class="headerlink" title="index()方法"></a>index()方法</h4><p>index()方法可以返回指定元素的下标，当一个元素多次重复出现时，则返回第一次出现的下标位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T = (1, 1, 2, 2, 3, 3, 1, 3, 5, 7, 9)</span><br><span class="line">T.index(9) # ==&gt; 10</span><br><span class="line">T.index(5) # ==&gt; 8</span><br><span class="line">T.index(1) # ==&gt; 0 # 多次出现，返回第一次出现的位置</span><br></pre></td></tr></table></figure>
<p><strong>注意，index()方法和count()方法不一样，当指定的元素不存在时，使用index()方法Python会报错。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T = (1, 1, 2, 2, 3, 3, 1, 3, 5, 7, 9)</span><br><span class="line">T.index(100)</span><br><span class="line"># 报错</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">ValueError: tuple.index(x): x not in tuple</span><br></pre></td></tr></table></figure>
<h3 id="Python创建单个元素的tuple"><a href="#Python创建单个元素的tuple" class="headerlink" title="Python创建单个元素的tuple"></a>Python创建单个元素的tuple</h3><p>tuple和list一样，可以包含 0 个、1个和任意多个元素。</p>
<p>包含多个元素的 tuple，前面我们已经创建过了。</p>
<p>包含 0 个元素的 tuple，也就是空tuple，直接用()表示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T = ()</span><br><span class="line">print(T) # ==&gt; ()</span><br></pre></td></tr></table></figure>
<p>接着，我们创建包含一个元素的tuple。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T = (1)</span><br><span class="line">print(T) # ==&gt; 1</span><br></pre></td></tr></table></figure>
<p>这和我们期望的输出有些差异，为什么包含一个元素的元组打印出来之后没有小括号，而是只有一个数字1呢？</p>
<p>回顾一下前面数字的四则运算。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">result = 3 * 4 - 2</span><br><span class="line">print(result) # ==&gt; 10</span><br><span class="line"></span><br><span class="line"># 改变优先级，先运算减法</span><br><span class="line"></span><br><span class="line">result = 3 * (4 - 2)</span><br><span class="line">print(result) # ==&gt; 6</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，改变优先级我们是通过()来实现的，这和元组的定义有冲突，这就解释了前面只有一个元素的元组，为什么打印出来却得到一个数字的结果了。</p>
<p>因为()既可以表示tuple，又可以作为括号表示运算时的优先级，结果(1)被Python解释器计算出结果 1，导致我们得到的不是tuple，而是整数 1。</p>
<p><strong>因此，要定义只有一个元素的tuple，需要在元素后面添加一个逗号,。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T = (1, )</span><br><span class="line">print(T) # ==&gt; (1, )</span><br></pre></td></tr></table></figure>
<p>而对于多个元素的tuple，则加和不加这个逗号，效果是一样的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; T = (1, 2, 3,)</span><br><span class="line">&gt;&gt;&gt; print(T) # ==&gt; (1, 2, 3)</span><br></pre></td></tr></table></figure>

<h3 id="Python的可变tuple"><a href="#Python的可变tuple" class="headerlink" title="Python的可变tuple"></a>Python的可变tuple</h3><p>前面我们学习了，对于tuple，它和list一个最大的不同点就是tuple是不可变的，tuple里面的元素，也是不可替换的。但是这针对的是仅包含基础数据类型（数字类型、布尔类型、字符串类型）的数据，对于组合数据类型，则不受这个约束。</p>
<p>T &#x3D; (1, ‘CH’, [3, 4])<br>这里T有三个元素，第一个元素是数字类型，第二个元素是字符串类型，第三个元素是列表类型的，我们尝试修改第三个元素的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">T = (1, &#x27;CH&#x27;, [3, 4])</span><br><span class="line">L = T[2]</span><br><span class="line">print(L) # ==&gt; [3, 4]</span><br><span class="line"># 尝试替换L中的元素</span><br><span class="line">L[1] = 40</span><br><span class="line">print(L) # ==&gt; [3, 40]</span><br><span class="line">print(T) # ==&gt; (1, &#x27;CH&#x27;, [3, 40])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个时候，我们发现，元组T中的第三个元素已经成功被改变了，这就有悖前面的定义，元组是不可改变的。那么这到底是为什么呢？</p>
<p>这是因为虽然tuple中的list元素改变了，但是tuple本身指向的list仍然是同一个list，list本身并没有改变，改变的只是list里面的一个元素，这是tuple所约束不到的范围。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">T = (1, &#x27;CH&#x27;, [3, 4])</span><br><span class="line">L2 = [3, 40]</span><br><span class="line"># 尝试替换tuple中的list</span><br><span class="line">T[2] = L2</span><br><span class="line"># 报错</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: &#x27;tuple&#x27; object does not support item assignment</span><br></pre></td></tr></table></figure>
<p>如果我们直接替换list，这也是不行的。</p>
<h3 id="什么是dict"><a href="#什么是dict" class="headerlink" title="什么是dict"></a>什么是dict</h3><p>我们已经知道，List 和 tuple 可以用来表示顺序集合，例如，班里同学的名字：</p>
<blockquote>
<p>[‘Alice’, ‘Bob’, ‘Candy’, ‘David’, ‘Ellena’] # List<br>(‘Alice’, ‘Bob’, ‘Candy’, ‘David’, ‘Ellena’) # tuple<br>或者考试的成绩：</p>
</blockquote>
<blockquote>
<p>[45, 60, 75, 86, 49] # list<br>(45, 60, 75, 86, 49) # tuple<br>如果同学名字的列表和同学成绩的列表是一一对应的，那么通过下标，我们也可以找到每个同学的成绩。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">names = [&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;Candy&#x27;, &#x27;David&#x27;, &#x27;Ellena&#x27;]</span><br><span class="line">scores = [45, 60, 75, 86, 49]</span><br><span class="line">index = 0</span><br><span class="line">for name in names:</span><br><span class="line">    score = scores[index]</span><br><span class="line">    print(&#x27;name = &#123;&#125;, score = &#123;&#125;&#x27;.format(name, score))</span><br><span class="line">    index = index + 1</span><br></pre></td></tr></table></figure>
<p>事实上，我们可以得到这样的映射。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x27;Alice&#x27; ==&gt; 45</span><br><span class="line">&#x27;Bob&#x27; ==&gt; 60</span><br><span class="line">&#x27;Candy&#x27; ==&gt; 75</span><br><span class="line">&#x27;David&#x27; ==&gt; 86</span><br><span class="line">&#x27;Ellena&#x27; ==&gt; 49</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是使用两个list，始终有些麻烦的，尤其是需要变换一个列表的顺序后，另外一个列表也需要做同样的变换，否则就可能出现对应不上的问题。<br>python的dict就是专门保存这种映射的，使用dict可以方便的保存“名字”-&gt;“成绩”的映射。<br>在dict中，每一项包含一个key和一个value，key和value是一一对应的，在解决上面的问题中，我们可以使用名字作为key，成绩作为value，那么dict的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;</span><br><span class="line">    &#x27;Alice&#x27;: 45,</span><br><span class="line">    &#x27;Bob&#x27;: 60,</span><br><span class="line">    &#x27;Candy&#x27;: 75,</span><br><span class="line">    &#x27;David&#x27;: 86,</span><br><span class="line">    &#x27;Ellena&#x27;: 49</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在定义里，我们使用花括号{}表示这是一个dict，然后key和value之间使用冒号:分割，并且每一组key:value的最后，以逗号,表示这一组的结束。</p>
<p>我们也可以使用以下的方式定义一个dict。</p>
<p>d &#x3D; dict()<br>print(d) # &#x3D;&#x3D;&gt; {}</p>
<p>不过这种定义方式，默认得到的是一个空dict，需要调用函数往里面添加数据，我们后面会继续学习。</p>
<h3 id="Python读取dict元素"><a href="#Python读取dict元素" class="headerlink" title="Python读取dict元素"></a>Python读取dict元素</h3><p>我们现在可以创建一个dict，保存名字和成绩的对应关系。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;</span><br><span class="line">    &#x27;Alice&#x27;: 45,</span><br><span class="line">    &#x27;Bob&#x27;: 60,</span><br><span class="line">    &#x27;Candy&#x27;: 75,</span><br><span class="line">    &#x27;David&#x27;: 86,</span><br><span class="line">    &#x27;Ellena&#x27;: 49,</span><br><span class="line">    &#x27;Gaven&#x27;: 86</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，如果想通过名字来查询某个同学的成绩，也就是通过key来查询value，这个时候怎么办呢？<br>dict提供通过key找到对应value的功能，通过d[key]的形式，就可以得到对应的value。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;</span><br><span class="line">    &#x27;Alice&#x27;: 45,</span><br><span class="line">    &#x27;Bob&#x27;: 60,</span><br><span class="line">    &#x27;Candy&#x27;: 75,</span><br><span class="line">    &#x27;David&#x27;: 86,</span><br><span class="line">    &#x27;Ellena&#x27;: 49,</span><br><span class="line">    &#x27;Gaven&#x27;: 86</span><br><span class="line">&#125;</span><br><span class="line">print(d[&#x27;Bob&#x27;]) # ==&gt; 60</span><br><span class="line">print(d[&#x27;Alice&#x27;]) # ==&gt; 45</span><br></pre></td></tr></table></figure>
<p>这和list通过下标找到对应位置的元素是类似的。<br>回顾一下前面使用下标的方式访问list元素的时候，当下标不存在时，就会引发错误，在dict中，也是一样的，当对应的key不存在时，也会引发错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;</span><br><span class="line">    &#x27;Alice&#x27;: 45,</span><br><span class="line">    &#x27;Bob&#x27;: 60,</span><br><span class="line">    &#x27;Candy&#x27;: 75,</span><br><span class="line">    &#x27;David&#x27;: 86,</span><br><span class="line">    &#x27;Ellena&#x27;: 49,</span><br><span class="line">    &#x27;Gaven&#x27;: 86</span><br><span class="line">&#125;</span><br><span class="line">print(d[&#x27;Dodo&#x27;])</span><br><span class="line"># 抛出异常</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">KeyError: &#x27;Dodo&#x27;</span><br></pre></td></tr></table></figure>
<p>它的意思是key不存在，因此我们在需要通过key找到value时，一定要先判断key存不存在，然后才使用上面的方式获取对应的value，以避免错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if &#x27;Alice&#x27; in d:</span><br><span class="line">    print(d[&#x27;Alice&#x27;]) # ==&gt; 45</span><br><span class="line">if &#x27;Dodo&#x27; in d: # Dodo不存在，所以不会走下面的逻辑</span><br><span class="line">    print(d[&#x27;Dodo&#x27;])</span><br></pre></td></tr></table></figure>

<p>除了使用这种方法，还有一种方法可以通过key来获取对应的value，这种方法不会引起错误，dict本身提供get方法，把key当作参数传递给get方法，就可以获取对应的value，当key不存在时，也不会报错，而是返回None。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(d.get(&#x27;Alice&#x27;)) # ==&gt; 45</span><br><span class="line">print(d.get(&#x27;Dodo&#x27;)) # ==&gt; None</span><br></pre></td></tr></table></figure>
<p>因为通过get方法在代码实现上更加简单，且不会引起错误，因此更加推荐使用get方法来获取dict的元素。</p>
<h3 id="Python添加dict元素"><a href="#Python添加dict元素" class="headerlink" title="Python添加dict元素"></a>Python添加dict元素</h3><p>dict和tuple不一样，dict是可变的，我们随时可以往dict中添加新的key-value，比如对于上节课的成绩dict：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;</span><br><span class="line">    &#x27;Alice&#x27;: 45,</span><br><span class="line">    &#x27;Bob&#x27;: 60,</span><br><span class="line">    &#x27;Candy&#x27;: 75,</span><br><span class="line">    &#x27;David&#x27;: 86,</span><br><span class="line">    &#x27;Ellena&#x27;: 49</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要往里面添加Dodo、Mimi的成绩时，可以使用赋值语句往里面添加元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d[&#x27;Mimi&#x27;] = 72</span><br><span class="line">d[&#x27;Dodo&#x27;] = 88</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure>
<p>实际上，value可以是任意类型的元素，可以是list、tuple等，假如Mimi近两次成绩分别是72，73，Dodo近两次的成绩分别是88，90，则可以使用赋值语句往dict中添加list元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d[&#x27;Mimi&#x27;] = [72, 73]</span><br><span class="line">d[&#x27;Dodo&#x27;] = [88, 90]</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure>
<p>此后，如果Mimi、Dodo的第三次成绩也出来了，分别是75，90，则可以先通过key把对应的value查询出来，然后再往类型是list的value中添加第三次的成绩。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d[&#x27;Mimi&#x27;].append(75)</span><br><span class="line">d[&#x27;Dodo&#x27;].append(90)</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure>
<h3 id="Python更新dict元素"><a href="#Python更新dict元素" class="headerlink" title="Python更新dict元素"></a>Python更新dict元素</h3><p>上一节课我们学习了往dict中添加元素的方法，通过赋值语句就可以把元素添加到dict中去，但是赋值的时候，我们并不确定key是否已经在dict里面了，如果dict里面已经有对应的key了，那将会发生什么呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;</span><br><span class="line">    &#x27;Alice&#x27;: 45,</span><br><span class="line">    &#x27;Bob&#x27;: 60,</span><br><span class="line">    &#x27;Candy&#x27;: 75,</span><br><span class="line">    &#x27;David&#x27;: 86,</span><br><span class="line">    &#x27;Ellena&#x27;: 49</span><br><span class="line">&#125;</span><br><span class="line">d[&#x27;Bob&#x27;] = 75</span><br><span class="line">print(d)</span><br><span class="line"># ==&gt; &#123;&#x27;Alice&#x27;: 45, &#x27;Bob&#x27;: 75, &#x27;Candy&#x27;: 75, &#x27;David&#x27;: 86, &#x27;Ellena&#x27;: 49&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候我们发现，原来Bob的成绩是60，现在变成75了，因为d[‘Bob’] &#x3D; 75的缘故。<br>因此我们发现这个赋值语句其实有两个功能：</p>
<p>当key不存在时，往dict中添加对应的key: value元素。<br>当key存在时，会更新dict，用新的value替换原来的value。<br>因此，在使用赋值语句往dict中添加元素时，为了避免不必要的覆盖问题，我们需要先判断key是否存在，然后再做更新。</p>
<h3 id="Python删除dict元素"><a href="#Python删除dict元素" class="headerlink" title="Python删除dict元素"></a>Python删除dict元素</h3><p>当同学转校时，我们需要把同学的成绩从已有的成绩dict中删除，这个时候我们就需要学习如何删除dict中的元素。</p>
<p>dict提供便捷的pop()方法，允许我们快速删除元素，pop()方法需要指定需要删除的元素的key，并返回对应的value。<br>假设Alice转校了，需要把Alice的成绩删除，可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;</span><br><span class="line">    &#x27;Alice&#x27;: 45,</span><br><span class="line">    &#x27;Bob&#x27;: 60,</span><br><span class="line">    &#x27;Candy&#x27;: 75,</span><br><span class="line">    &#x27;David&#x27;: 86,</span><br><span class="line">    &#x27;Ellena&#x27;: 49</span><br><span class="line">&#125;</span><br><span class="line">print(d) # ==&gt; &#123;&#x27;Alice&#x27;: 45, &#x27;Bob&#x27;: 60, &#x27;Candy&#x27;: 75, &#x27;David&#x27;: 86, &#x27;Ellena&#x27;: 49&#125;</span><br><span class="line">alice_score= d.pop(&#x27;Alice&#x27;)</span><br><span class="line">print(alice_score) # ==&gt; 45</span><br><span class="line">print(d) # ==&gt; &#123;&#x27;Bob&#x27;: 60, &#x27;Candy&#x27;: 75, &#x27;David&#x27;: 86, &#x27;Ellena&#x27;: 49&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，pop()方法的参数是dict中的key，当key不存在时，同样会引起错误。比如在上述操作中，已经把Alice的成绩删除了，假如再次pop(‘Alice’)，将会引发错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d.pop(&#x27;Alice&#x27;)</span><br><span class="line"># 报错</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">KeyError: &#x27;Alice&#x27;</span><br></pre></td></tr></table></figure>

<p>在dict中，使用keys()方法，可以返回dict的所有key，在删除某个元素时，可以通过这个方法先判断某个元素是否存在，请改造前面的程序，使得即使key不存在时，删除也不会抛异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;</span><br><span class="line">    &#x27;Alice&#x27;: 45,</span><br><span class="line">    &#x27;Bob&#x27;: 60,</span><br><span class="line">    &#x27;Candy&#x27;: 75,</span><br><span class="line">    &#x27;David&#x27;: 86,</span><br><span class="line">    &#x27;Ellena&#x27;: 49</span><br><span class="line">&#125;</span><br><span class="line">name = &#x27;Alice&#x27;</span><br><span class="line">if name in d.keys():</span><br><span class="line">    d.pop(name)</span><br><span class="line">else:</span><br><span class="line">    print(&#x27;&#123;&#125; not in d&#x27;.format(name))</span><br></pre></td></tr></table></figure>

<h3 id="Python-dict的特点"><a href="#Python-dict的特点" class="headerlink" title="Python dict的特点"></a>Python dict的特点</h3><p><strong>查找速度快</strong></p>
<p>dict的第一个特点是查找速度快，无论dict有10个元素还是10万个元素，查找速度都一样。而list的查找速度随着元素增加而逐渐下降。<br>不过dict的查找速度快不是没有代价的，dict的缺点是占用内存大，还会浪费很多内容，list正好相反，占用内存小，但是查找速度慢。</p>
<p><strong>有序与无序</strong></p>
<p>在Python3.5之前，dict中的元素是无序的，也就是dict中元素的插入顺序和打印顺序未必一致，比如使用Python3.5之前的版本执行以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;</span><br><span class="line">    &#x27;Alice&#x27;: 45,</span><br><span class="line">    &#x27;Bob&#x27;: 60,</span><br><span class="line">    &#x27;Candy&#x27;: 75,</span><br><span class="line">    &#x27;David&#x27;: 86,</span><br><span class="line">    &#x27;Ellena&#x27;: 49</span><br><span class="line">&#125;</span><br><span class="line">print(d) # ==&gt; &#123;&#x27;Bob&#x27;: 60, &#x27;Ellena&#x27;: 49, &#x27;Alice&#x27;: 45, &#x27;Candy&#x27;: 75, &#x27;David&#x27;: 86&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，打印的顺序和定义的顺序并不一致。<br>但是在Python3.6、Python3.7版本中，却得到了有序的结果。</p>
<p>print(d) # &#x3D;&#x3D;&gt; {‘Alice’: 45, ‘Bob’: 60, ‘Candy’: 75, ‘David’: 86, ‘Ellena’: 49}<br>为什么在不同的版本中，会得到不一样的结果呢？这是因为底层的实现发生了改变，我们可以认为在Python3.6的版本以后，dict是有序的，但是一般而言，为了避免不必要的误解，一般在需要有序的dict时，我们会使用一种叫做Ordereddict的字典，来确保有序。</p>
<p><strong>key不可变</strong></p>
<p>对于基础数据类型，字符串、数字等，这些都是不可变的，可以作为dict的key，而对于复杂数据类型，经过前面的学习，我们知道tuple是不可变的，list是可变的，因此tuple可以作为dict的key，但是list不可以作为dict的key，否则将会报错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">key = (1, 2, 3) # 以tuple作为key</span><br><span class="line">d[key] = True</span><br><span class="line">key = [1, 2, 3]</span><br><span class="line">d[key] = True</span><br><span class="line"># 报错</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: unhashable type: &#x27;list&#x27;</span><br></pre></td></tr></table></figure>
<p>如上所示，如果将list作为dict的key，将会引起错误。<br>由于dict是按 key 查找，所以，在一个dict中，key不能重复。</p>
<p><strong>Python遍历dict</strong></p>
<p>通过直接print(d)，我们打印出来的是完整的一个dict；有时候，我们需要把dict中m一定条件的元素打印出来，比如成绩超过60的，在这种情况下，我们需要则需要遍历dict（这种时候需要使用for循环），并通过条件判断把满足条件的打印出来。<br>遍历dict有两种方法， 第一种是遍历dict的所有key，并通过key获得对应的value。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;</span><br><span class="line">    &#x27;Alice&#x27;: 45,</span><br><span class="line">    &#x27;Bob&#x27;: 60,</span><br><span class="line">    &#x27;Candy&#x27;: 75,</span><br><span class="line">    &#x27;David&#x27;: 86,</span><br><span class="line">    &#x27;Ellena&#x27;: 49</span><br><span class="line">&#125;</span><br><span class="line">for key in d: # 遍历d的key</span><br><span class="line">    value = d[key]</span><br><span class="line">    if value &gt; 60:</span><br><span class="line">        print(key, value)</span><br><span class="line"># ==&gt; Candy 75</span><br><span class="line"># ==&gt; David 86</span><br></pre></td></tr></table></figure>
<p>第二种方法是通过dict提供的items()方法，items()方法会返回dict中所有的元素，每个元素包含key和value。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for key, value in d.items():</span><br><span class="line">    if value &gt; 60:</span><br><span class="line">        print(key, value)</span><br><span class="line"># ==&gt; Candy 75</span><br><span class="line"># ==&gt; David 86</span><br></pre></td></tr></table></figure>

<h3 id="Python操作dict的其他方法"><a href="#Python操作dict的其他方法" class="headerlink" title="Python操作dict的其他方法"></a>Python操作dict的其他方法</h3><p>除了前面学习的增删改查，dict还提供了非常多的工具函数帮助我们方便快捷地使用dict。</p>
<p><strong>获取dict的所有key</strong></p>
<p>dict提供keys()函数，可以返回dict中所有的key。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&#x27;Alice&#x27;: [50, 61, 66], &#x27;Bob&#x27;: [80, 61, 66], &#x27;Candy&#x27;: [88, 75, 90]&#125;</span><br><span class="line">for key in d.keys():</span><br><span class="line">    print(key)</span><br><span class="line"># ==&gt; Alice</span><br><span class="line"># ==&gt; Bob</span><br><span class="line"># ==&gt; Candy</span><br></pre></td></tr></table></figure>
<p><strong>获取dict所有的value</strong></p>
<p>dict提供values()函数，可以返回dict中所有的value。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&#x27;Alice&#x27;: [50, 61, 66], &#x27;Bob&#x27;: [80, 61, 66], &#x27;Candy&#x27;: [88, 75, 90]&#125;</span><br><span class="line">for key in d.values():</span><br><span class="line">    print(key)</span><br><span class="line"># ==&gt; [50, 61, 66]</span><br><span class="line"># ==&gt; [80, 61, 66]</span><br><span class="line"># ==&gt; [88, 75, 90]</span><br></pre></td></tr></table></figure>
<p><strong>清除所有元素</strong></p>
<p>dict提供clear()函数，可以直接清除dict中所有的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&#x27;Alice&#x27;: [50, 61, 66], &#x27;Bob&#x27;: [80, 61, 66], &#x27;Candy&#x27;: [88, 75, 90]&#125;</span><br><span class="line">print(d) # ==&gt; &#123;&#x27;Alice&#x27;: [50, 61, 66], &#x27;Bob&#x27;: [80, 61, 66], &#x27;Candy&#x27;: [88, 75, 90]&#125;</span><br><span class="line">d.clear()</span><br><span class="line">print(d) # ==&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="什么是set"><a href="#什么是set" class="headerlink" title="什么是set"></a>什么是set</h3><p>在前面，我们学习了dict，知道dict的key是不重复的，当我们往dict里添加一个相同key的value时，新的value将会覆盖旧的value。</p>
<p>有的时候，我们只想要 dict 的 key，不关心 key 对应的 value，目的就是保证这个集合的元素不会重复，这时，set就派上用场了。</p>
<p>set和list类似，拥有一系列元素，但是set和list不一样，set里面的元素是不允许重复的，而list里面可以包含相同的元素；</p>
<p>set与list的另一个区别是，set里面的元素是没有顺序的。</p>
<p>创建set的方式是使用set()，并传入一个list，list的元素将会被转换成set的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = set([1, 4, 3, 2, 5])</span><br><span class="line">print(s) # ==&gt; set([1, 2, 3, 4, 5])</span><br></pre></td></tr></table></figure>
<p>需要注意的是，上述打印的形式类似 list， 但它不是 list，仔细看还可以发现，打印的顺序和原始 list 的顺序有可能是不同的，因为set内部存储的元素是无序的。</p>
<p>另外，set不能包含重复的元素，我们传入重复的元素看看会发生什么。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = set([1, 4, 3, 2, 5, 4, 2, 3, 1])</span><br><span class="line">print(s) # ==&gt; set([1, 2, 3, 4, 5])</span><br></pre></td></tr></table></figure>
<p>可以看到，在传入set()的list中，包含了重复的元素，但是打印的时候，相同的元素只保留了一个，重复的元素都被去掉了，这是set的一个重要特点。</p>
<h3 id="Python读取set元素"><a href="#Python读取set元素" class="headerlink" title="Python读取set元素"></a>Python读取set元素</h3><p>由于set里面的元素是没有顺序的，因此我们不能像list那样通过索引来访问。访问set中的某个元素实际上就是判断一个元素是否在set中，这个时候我们可以使用in来判断某个元素是否在set中。<br>比如，存储了班里同学名字的set。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">names = [&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;Candy&#x27;, &#x27;David&#x27;, &#x27;Ellena&#x27;]</span><br><span class="line">name_set = set(names)</span><br><span class="line">请问&#x27;Alice&#x27;是班里面的同学吗？</span><br><span class="line"></span><br><span class="line">&#x27;Alice&#x27; in name_set # ==&gt; True</span><br><span class="line">请问&#x27;Bobby&#x27;是班里面的同学吗？</span><br><span class="line"></span><br><span class="line">&#x27;Bobby&#x27; in name_set # ==&gt;False</span><br><span class="line">请问&#x27;bob&#x27;是班里面的同学吗？</span><br><span class="line"></span><br><span class="line">&#x27;bob&#x27; in name_set # ==&gt; False</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个时候是否输出了不符合预期的结果？</p>
<p>‘Bob’是在name_set里面的，为什么输出了False呢？这是因为set元素是区分大小写的，必须大小写完全匹配，才能判断该元素在set里面。</p>
<h3 id="Python添加set元素"><a href="#Python添加set元素" class="headerlink" title="Python添加set元素"></a>Python添加set元素</h3><p>我们通过set()传入list的方法创建了set，如果set在使用过程中需要往里面添加元素，这个时候应该怎么添加呢？<br>set提供了add()方法，我们可以使用add()方法，往set里面添加元素。<br>比如，班里面来了新的同学，名字叫Gina。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">names = [&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;Candy&#x27;, &#x27;David&#x27;, &#x27;Ellena&#x27;]</span><br><span class="line">name_set = set(names)</span><br><span class="line">name_set.add(&#x27;Gina&#x27;)</span><br><span class="line">print(name_set) # ==&gt; set([&#x27;Gina&#x27;, &#x27;Alice&#x27;, &#x27;Candy&#x27;, &#x27;David&#x27;, &#x27;Ellena&#x27;, &#x27;Bob&#x27;])</span><br></pre></td></tr></table></figure>
<p>可以看到，’Gina’已经添加到name_set里面去了。对于set，如果添加一个已经存在的元素，不会报错，也不会改变什么。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">names = [&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;Candy&#x27;, &#x27;David&#x27;, &#x27;Ellena&#x27;]</span><br><span class="line">name_set = set(names)</span><br><span class="line">name_set.add(&#x27;Alice&#x27;)</span><br><span class="line">print(name_set) # ==&gt; set([&#x27;Bob&#x27;, &#x27;Ellena&#x27;, &#x27;Alice&#x27;, &#x27;Candy&#x27;, &#x27;David&#x27;])</span><br></pre></td></tr></table></figure>
<p>有些时候需要批量往set里面添加元素，如果一个一个add是比较麻烦的，有没有批量往set里面添加元素的方法呢？<br>set提供了update()方法，可以一次性给set添加多个元素。<br>比如，新来了一批同学，名字分别是[‘Hally’,  ‘Isen’,  ‘Jenny’,  ‘Karl’]，则可以使用update()方法，批量往set中添加。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">names = [&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;Candy&#x27;, &#x27;David&#x27;, &#x27;Ellena&#x27;]</span><br><span class="line">new_names = [&#x27;Hally&#x27;, &#x27;Isen&#x27;, &#x27;Jenny&#x27;, &#x27;Karl&#x27;]</span><br><span class="line">name_set = set(names)</span><br><span class="line">name_set.update(new_names) # ==&gt; set([&#x27;Jenny&#x27;, &#x27;Ellena&#x27;, &#x27;Alice&#x27;, &#x27;Candy&#x27;, &#x27;David&#x27;, &#x27;Hally&#x27;, &#x27;Bob&#x27;, &#x27;Isen&#x27;, &#x27;Karl&#x27;])</span><br><span class="line">print(name_set)</span><br></pre></td></tr></table></figure>

<h3 id="Python删除set元素"><a href="#Python删除set元素" class="headerlink" title="Python删除set元素"></a>Python删除set元素</h3><p>和list、dict一样，有时候我们也需要考虑删除set的元素。<br>set提供了remove()方法允许我们删除set中的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name_set = set([&#x27;Jenny&#x27;, &#x27;Ellena&#x27;, &#x27;Alice&#x27;, &#x27;Candy&#x27;, &#x27;David&#x27;, &#x27;Hally&#x27;, &#x27;Bob&#x27;, &#x27;Isen&#x27;, &#x27;Karl&#x27;])</span><br><span class="line">name_set.remove(&#x27;Jenny&#x27;)</span><br><span class="line">print(name_set) # ==&gt; set([&#x27;Ellena&#x27;, &#x27;Alice&#x27;, &#x27;Candy&#x27;, &#x27;David&#x27;, &#x27;Hally&#x27;, &#x27;Bob&#x27;, &#x27;Isen&#x27;, &#x27;Karl&#x27;])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果remove的元素不在set里面的话，那么将会引发错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">name_set = set([&#x27;Jenny&#x27;, &#x27;Ellena&#x27;, &#x27;Alice&#x27;, &#x27;Candy&#x27;, &#x27;David&#x27;, &#x27;Hally&#x27;, &#x27;Bob&#x27;, &#x27;Isen&#x27;, &#x27;Karl&#x27;])</span><br><span class="line">name_set.remove(&#x27;Jenny&#x27;)</span><br><span class="line">print(name_set) # ==&gt; set([&#x27;Ellena&#x27;, &#x27;Alice&#x27;, &#x27;Candy&#x27;, &#x27;David&#x27;, &#x27;Hally&#x27;, &#x27;Bob&#x27;, &#x27;Isen&#x27;, &#x27;Karl&#x27;])</span><br><span class="line">name_set.remove(&#x27;Jenny&#x27;) # ==&gt; 重复remove &#x27;Jenny&#x27;</span><br><span class="line"># 引起错误</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">KeyError: &#x27;Jenny&#x27;</span><br></pre></td></tr></table></figure>
<p>因此，使用remove()方法，我们需要格外小心，需要提前判断要remove()的元素是否在set里面，确保存在后，再进行remove。</p>
<h3 id="Python-操作set的其他方法"><a href="#Python-操作set的其他方法" class="headerlink" title="Python 操作set的其他方法"></a>Python 操作set的其他方法</h3><p><strong>不会报错的删除方法discard()</strong></p>
<p>除了使用remove()方法删除元素以外，还可以使用discard()方法删除元素，并且，和remove()不同的是，当元素不存在时，使用discard()并不会引发错误，所以使用discard()是更加高效的一个方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name_set = set([&#x27;Jenny&#x27;, &#x27;Ellena&#x27;, &#x27;Alice&#x27;, &#x27;Candy&#x27;, &#x27;David&#x27;, &#x27;Hally&#x27;, &#x27;Bob&#x27;, &#x27;Isen&#x27;, &#x27;Karl&#x27;])</span><br><span class="line">name_set.discard(&#x27;Jenny&#x27;)</span><br><span class="line">print(name_set) # ==&gt; set([&#x27;Ellena&#x27;, &#x27;Alice&#x27;, &#x27;Candy&#x27;, &#x27;David&#x27;, &#x27;Hally&#x27;, &#x27;Bob&#x27;, &#x27;Isen&#x27;, &#x27;Karl&#x27;])</span><br><span class="line">name_set.discard(&#x27;Jenny&#x27;)</span><br><span class="line">print(name_set) # ==&gt; set([&#x27;Ellena&#x27;, &#x27;Alice&#x27;, &#x27;Candy&#x27;, &#x27;David&#x27;, &#x27;Hally&#x27;, &#x27;Bob&#x27;, &#x27;Isen&#x27;, &#x27;Karl&#x27;]</span><br></pre></td></tr></table></figure>
<p>清除所有元素的方法clear()</p>
<p>和dict一样，set也提供了clear()方法，可以快速清除set中的所有元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name_set = set([&#x27;Jenny&#x27;, &#x27;Ellena&#x27;, &#x27;Alice&#x27;, &#x27;Candy&#x27;, &#x27;David&#x27;, &#x27;Hally&#x27;, &#x27;Bob&#x27;, &#x27;Isen&#x27;, &#x27;Karl&#x27;])</span><br><span class="line">print(name_set) # ==&gt; set([&#x27;Jenny&#x27;, &#x27;Ellena&#x27;, &#x27;Alice&#x27;, &#x27;Candy&#x27;, &#x27;David&#x27;, &#x27;Hally&#x27;, &#x27;Bob&#x27;, &#x27;Isen&#x27;, &#x27;Karl&#x27;])</span><br><span class="line">name_set.clear()</span><br><span class="line">print(name_set) # ==&gt; set([])</span><br></pre></td></tr></table></figure>
<p><strong>集合的子集和超集</strong></p>
<p>set提供方法判断两个set之间的关系，比如两个集合set，判断其中一个set是否为另外一个set的子集或者超集。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s1 = set([1, 2, 3, 4, 5])</span><br><span class="line">s2 = set([1, 2, 3, 4, 5, 6, 7, 8, 9])</span><br><span class="line"># 判断s1是否为s2的子集</span><br><span class="line">s1.issubset(s2) # ==&gt; True</span><br><span class="line"># 判断s2是否为s1的超集</span><br><span class="line">s2.issuperset(s1) # ==&gt; True</span><br><span class="line">判断集合是否重合</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>有时候需要判断两个集合是否有重合的地方，如果使用传统的方法，需要使用for循环一个一个的去判断，非常麻烦，set提供isdisjoint()方法，可以快速判断两个集合是否有重合，如果有重合，返回False，否则返回True。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s1 = set([1, 2, 3, 4, 5])</span><br><span class="line">s2 = set([1, 2, 3, 4, 5, 6, 7, 8, 9])</span><br><span class="line">s1.isdisjoint(s2) # ==&gt; False，因为有重复元素1、2、3、4、5</span><br></pre></td></tr></table></figure>
<h3 id="Python调用函数"><a href="#Python调用函数" class="headerlink" title="Python调用函数"></a>Python调用函数</h3><p>Python内置了很多有用的函数，我们可以直接调用。比如前面求list的长度len()函数等等，都是Python内置的函数，我们经常会使用到它们。<br>在这个文档里面，列举了Python内置的大部分函数，同学们有兴趣可以参考看看。</p>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/3/library/functions.html">https://docs.python.org/3/library/functions.html</a><br>要调用一个函数，需要知道函数的名称和参数，比如求绝对值的函数 abs()，它接收一个参数。<br>对于abs()函数，abs就是函数的名称，括号()内，就是函数的参数，当函数没有参数时，默认就是一个空括号。abs接收一个参数，这个参数就是需要求绝对值的数，这个参数可以是整数，也可以是浮点数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abs(-100) # ==&gt; 100</span><br><span class="line">abs(20) # ==&gt; 20</span><br><span class="line">abs(-3.14159) # ==&gt; 3.14159</span><br></pre></td></tr></table></figure>
<p>需要注意的是，传递的参数数量一定要和函数要求的一致，不然将会引起错误，比如，如果在abs()函数中传入两个参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abs(1, 2)</span><br><span class="line"># 报错</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: abs() takes exactly one argument (2 given)</span><br></pre></td></tr></table></figure>
<p>在错误提示中，清晰的说明了abs()函数只接收一个参数，但是却传递了两个参数，所以引起了错误。<br>其次，如果传入的参数数量是对的，但是参数的类型不能被函数所接受，也会引起错误，比如：求绝对值的函数abs()，只有数字才拥有绝对值，如果传递一个字符串进去，将会引起错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abs(&#x27;3.1415926&#x27;)</span><br><span class="line"># 报错</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: bad operand type for abs(): &#x27;str&#x27;</span><br></pre></td></tr></table></figure>
<p>这里错误提示说，str类型是错误的参数类型。<br>除了abs()函数，还有很多常见的函数，比如cmp()函数，可以比较两个数的大小，这个时候，cmp()函数就接收两个参数。<br>对于cmp(x, y)，如果x &lt; y 返回 -1，如果x &#x3D;&#x3D; y 函数返回0，如果x &gt; y函数返回1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmp(1, 2) # ==&gt; -1</span><br><span class="line">cmp(2, 1) # ==&gt; 1</span><br><span class="line">cmp(3, 3) # ==&gt; 0</span><br></pre></td></tr></table></figure>
<p>还有基础数据类型的转换函数，int()函数可以将合法的其它类型数据转换为整数，str()函数可以将其它类型的数据转换为字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int(&#x27;123&#x27;) # ==&gt; 123</span><br><span class="line">int(12.34) # ==&gt; 12</span><br><span class="line"></span><br><span class="line">str(123) # ==&gt; &#x27;123&#x27;</span><br><span class="line">str(1.23) # ==&gt; &#x27;1.23&#x27;</span><br></pre></td></tr></table></figure>
<p>在学习Python的过程中，我们将会接触到越来越多的Python内置函数，这些内置函数提供了非常有用的功能，大大降低我们编程的难度。</p>
<h3 id="Python定义函数"><a href="#Python定义函数" class="headerlink" title="Python定义函数"></a>Python定义函数</h3><p>除了使用Python内置的函数以外，在编程过程中，我们也经常需要自己定义函数。</p>
<p>在Python中，定义一个函数要使用 def 语句，依次写出函数名、括号()、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用 return 语句返回。</p>
<p>我们以定义一个求绝对值的函数my_abs函数为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def my_abs(x):</span><br><span class="line">    if x &gt;= 0:</span><br><span class="line">        return x</span><br><span class="line">    else:</span><br><span class="line">        return -x</span><br></pre></td></tr></table></figure>
<p>请注意，return表示返回的意思，函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。<br>我们继续定义一个求列表list所有元素的和的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def list_sum(L):</span><br><span class="line">    result = 0</span><br><span class="line">    for num in L:</span><br><span class="line">        result = result + num</span><br><span class="line">    return result</span><br></pre></td></tr></table></figure>
<p>这样子我们就定义了一个sum_list()的函数，注意，在最后return，我们把求和的结果result返回了，这样就可以在外部调用函数后获得result。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L = [1, 3, 5, 7, 9, 11]</span><br><span class="line">result =list_sum(L) # 调用定义的sum_list函数并获得return返回的结果</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
<h3 id="Python函数返回值"><a href="#Python函数返回值" class="headerlink" title="Python函数返回值"></a>Python函数返回值</h3><p>在上一节课中，我们在函数里面使用return返回了计算的结果，在外部调用这个函数的时候，就可以接收到结果。<br>有时候函数是没有返回结果的，这个时候从函数获取到的是一个空值None。<br>我们对list_sum()这个函数进行简单的修改，在函数内把结果打印出来，不通过return返回结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def list_sum(l):</span><br><span class="line">    result = 0</span><br><span class="line">    for num in l:</span><br><span class="line">        result = result + num</span><br><span class="line">    print(&#x27;result is &#123;&#125;&#x27;.format(result))</span><br><span class="line">    return</span><br><span class="line"></span><br><span class="line">l = [1, 3, 5, 7, 9, 11]</span><br><span class="line">result =list_sum(l) # 调用定义的sum_list函数并获得return返回的结果</span><br><span class="line">print(result) # ==&gt; None</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在print(result)中，我们得到None的结果，这是合理的，因为在函数内部，我们把结果打印出来了，但是没有把结果返回。<br>除了返回None、一个值以外，函数也可以返回多个值，在函数中，如果需要返回多个值，多个值之间使用逗号分隔即可，但是需要注意顺序。<br>比如，定义一个函数data_of_square，接收边长一个参数，同时返回正方形的周长和面积。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def data_of_square(side):</span><br><span class="line">    C = 4 * side</span><br><span class="line">    S = side * side</span><br><span class="line">    return C, S</span><br><span class="line"></span><br><span class="line">C, S = data_of_square(16)</span><br><span class="line">print(&#x27;周长 = &#123;&#125;&#x27;.format(C)) # ==&gt; 周长 = 64</span><br><span class="line">print(&#x27;面积 = &#123;&#125;&#x27;.format(S)) # ==&gt; 面积 = 256</span><br></pre></td></tr></table></figure>
<p>也可以使用一个值存储函数返回的多值结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = data_of_square(16)</span><br><span class="line">print(result) # ==&gt; (64, 256)</span><br></pre></td></tr></table></figure>
<p>注意打印的result，其实它是tuple类型，如果我们需要取出结果中的周长或者面积，使用对应位置的下标就可以获得对应的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result = data_of_square(16)</span><br><span class="line">C = result[0]</span><br><span class="line">S = result[1]</span><br><span class="line">print(&#x27;周长 = &#123;&#125;&#x27;.format(C)) # ==&gt; 周长 = 64</span><br><span class="line">print(&#x27;面积 = &#123;&#125;&#x27;.format(S)) # ==&gt; 面积 = 256</span><br></pre></td></tr></table></figure>
<h3 id="Python递归函数"><a href="#Python递归函数" class="headerlink" title="Python递归函数"></a>Python递归函数</h3><p>在函数内部，还可以调用其他函数，比如实现函数data_of_square的时候，它接收边长一个参数，同时返回正方形的周长和面积，而求周长和求面积是完全独立的逻辑，可以定义成两个新的函数，然后在data_of_square函数中再调用这两个函数，得到结果并返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def square_area(side):</span><br><span class="line">    return side * side</span><br><span class="line"></span><br><span class="line">def square_perimeter(side):</span><br><span class="line">    return 4 * side</span><br><span class="line"></span><br><span class="line">def data_of_square(side):</span><br><span class="line">    C = square_perimeter(side)</span><br><span class="line">    S = square_area(side)</span><br><span class="line">    return C, S</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在函数内部调用其他函数，是非常常见的，通过合理拆分逻辑，可以降低程序的复杂度。如果在一个函数内部调用其自身，这个函数就是递归函数。</p>
<p>举个例子，我们来计算阶乘 n! &#x3D; 1 * 2 * 3 * … * n，用函数 fact(n)表示，可以看出：</p>
<p>fact(n) &#x3D; n! &#x3D; 1 * 2 * 3 * … * (n-1) * n &#x3D; (n-1)! * n &#x3D; fact(n-1) * n</p>
<p>所以，fact(n)可以表示为 n * fact(n-1)，只有n&#x3D;1时需要特殊处理。</p>
<p>于是，fact(n)用递归的方式写出来就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def fact(n):</span><br><span class="line">    if n==1:</span><br><span class="line">        return 1</span><br><span class="line">    return n * fact(n - 1)</span><br></pre></td></tr></table></figure>
<p>这个fact(n)就是递归函数，可以试试计算得到的结果。</p>
<blockquote>
<p>fact(1) # &#x3D;&#x3D;&gt; 1<br>fact(5) # &#x3D;&#x3D;&gt; 120</p>
</blockquote>
<p>我们可以拆解fact(5)计算的详细逻辑</p>
<blockquote>
<p>&#x3D;&#x3D;&#x3D;&gt; fact(5)<br>&#x3D;&#x3D;&#x3D;&gt; 5 * fact(4)<br>&#x3D;&#x3D;&#x3D;&gt; 5 * (4 * fact(3))<br>&#x3D;&#x3D;&#x3D;&gt; 5 * (4 * (3 * fact(2)))<br>&#x3D;&#x3D;&#x3D;&gt; 5 * (4 * (3 * (2 * fact(1))))<br>&#x3D;&#x3D;&#x3D;&gt; 5 * (4 * (3 * (2 * 1)))<br>&#x3D;&#x3D;&#x3D;&gt; 5 * (4 * (3 * 2))<br>&#x3D;&#x3D;&#x3D;&gt; 5 * (4 * 6)<br>&#x3D;&#x3D;&#x3D;&gt; 5 * 24<br>&#x3D;&#x3D;&#x3D;&gt; 120</p>
</blockquote>
<p>递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。<br>使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试计算 fact(10000)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">RecursionError: maximum recursion depth exceeded in comparison</span><br></pre></td></tr></table></figure>
<h3 id="Python函数参数"><a href="#Python函数参数" class="headerlink" title="Python函数参数"></a>Python函数参数</h3><p>函数参数是需要传递给函数内部的数据，在前面，我们已经简单接触了函数的参数，现在我们正式来认识它。<br>函数参数可以是任意的数据类型，只要函数内部逻辑可以处理即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def print_param(param):</span><br><span class="line">    print(param)</span><br></pre></td></tr></table></figure>
<p>对于print_param函数，由于函数的逻辑是直接打印参数，并没有做任何别的逻辑，所以这个函数可以接受整数、浮点数、list、tuple、dict等等的数据类型。</p>
<blockquote>
<p>print_param(1)<br>print_param(‘3.1415926’)<br>print_param([1, 2, 3, 4, 5])<br>但是，有时候由于函数的实现关系，需要特定的参数，就比如前面实现的求绝对值的函数my_abs()，如果传递一个字符串，就会引起错误。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def my_abs(x):</span><br><span class="line">    if x &gt;= 0:</span><br><span class="line">        return x</span><br><span class="line">    else:</span><br><span class="line">        return -x</span><br><span class="line"></span><br><span class="line">my_abs(&#x27;str param&#x27;)</span><br><span class="line"># 报错</span><br><span class="line">TypeError: &#x27;&gt;=&#x27; not supported between instances of &#x27;str&#x27; and &#x27;int&#x27;</span><br></pre></td></tr></table></figure>
<p>为了保证函数的正常运行，有时候需要对函数入参进行类型的校验，Python提供isinstance()函数，可以判断参数类型，它接收两个参数，第一个是需要判断的参数，第二个是类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">isinstance(100, int) # ==&gt; True</span><br><span class="line">isinstance(100.0, int) # ==&gt; False</span><br><span class="line">isinstance(&#x27;3.1415926&#x27;, str) # ==&gt; True</span><br><span class="line">有了isinstance，就可以优化my_abs函数，不在里面运行出错了。</span><br><span class="line"></span><br><span class="line">def my_abs(x):</span><br><span class="line">    if not isinstance(x, int) or not isinstance(x, float):</span><br><span class="line">        print(&#x27;param type error.&#x27;)</span><br><span class="line">        return None</span><br><span class="line">    if x &gt;= 0:</span><br><span class="line">        return x</span><br><span class="line">    else:</span><br><span class="line">        return -x</span><br></pre></td></tr></table></figure>
<h3 id="Python函数使用默认参数"><a href="#Python函数使用默认参数" class="headerlink" title="Python函数使用默认参数"></a>Python函数使用默认参数</h3><p>定义函数的时候，还可以有默认参数，默认参数的意思是当这个参数没有传递的时候，参数就使用定义时的默认值。<br>例如Python自带的 int() 函数，其实就有两个参数，我们既可以传一个参数，又可以传两个参数：</p>
<blockquote>
<p>int(‘123’) # &#x3D;&#x3D;&gt; 123<br>int(‘123’, 8) # &#x3D;&#x3D;&gt; 83</p>
</blockquote>
<p>int()函数的第二个参数是转换进制base，如果不传，默认是十进制 (base&#x3D;10)，如果传了，就用传入的参数。<br>可见，函数的默认参数的作用是简化调用，你只需要把必须的参数传进去。但是在需要的时候，又可以传入额外的参数来覆盖默认参数值。<br>我们来定义一个计算 x 的N次方的函数:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def power(x, n):</span><br><span class="line">    s = 1</span><br><span class="line">    while n &gt; 0:</span><br><span class="line">        n = n - 1</span><br><span class="line">        s = s * x</span><br><span class="line">    return s</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>假设计算平方的次数最多，我们就可以把 n 的默认值设定为 2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def power(x, n=2):</span><br><span class="line">    s = 1</span><br><span class="line">    while n &gt; 0:</span><br><span class="line">        n = n - 1</span><br><span class="line">        s = s * x</span><br><span class="line">    return s</span><br></pre></td></tr></table></figure>
<p>这样一来，计算平方就不需要传入两个参数了：</p>
<p><code>power(5) # ==&gt; 25</code><br>另外需要注意的是，由于函数的参数按从左到右的顺序匹配，所以默认参数只能定义在必需参数的后面，否则将会出现错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 错误的定义</span><br><span class="line">def power(n=2, x):</span><br><span class="line">    s = 1</span><br><span class="line">    while n &gt; 0:</span><br><span class="line">        n = n - 1</span><br><span class="line">        s = s * x</span><br><span class="line">    return s</span><br></pre></td></tr></table></figure>

<h3 id="Python函数使用可变参数"><a href="#Python函数使用可变参数" class="headerlink" title="Python函数使用可变参数"></a>Python函数使用可变参数</h3><p>除了默认参数，Python函数还接收一种参数叫做可变参数，可变参数即任意个参数的意思，可变参数通常使用*args来表示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def func(*args):</span><br><span class="line">    print(&#x27;args length = &#123;&#125;, args = &#123;&#125;&#x27;.format(len(args), args))</span><br><span class="line"></span><br><span class="line">func(&#x27;a&#x27;) # ==&gt; args length = 1, args = (&#x27;a&#x27;,)</span><br><span class="line">func(&#x27;a&#x27;, &#x27;b&#x27;) # ==&gt; args length = 2, args = (&#x27;a&#x27;, &#x27;b&#x27;)</span><br><span class="line">func(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;) # ==&gt; args length = 3, args = (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;)</span><br></pre></td></tr></table></figure>
<p><strong>注意，在使用上，Python会把可变参数定义为一个tuple，所以在函数内部，把可变参数当作tuple来使用就可以了，比如可以通过位置下标取出对应的元素等。</strong></p>
<p>定义可变参数的目的也是为了简化调用。假设我们要计算任意个数的平均值，就可以定义一个可变参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def average(*args):</span><br><span class="line">    sum = 0</span><br><span class="line">    for item in args:</span><br><span class="line">        sum += item</span><br><span class="line">    avg = sum / len(args)</span><br><span class="line">    return avg</span><br></pre></td></tr></table></figure>
<p>这样，在调用的时候，我们就可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">average(1, 2) # ==&gt; 1.5</span><br><span class="line">average(1, 2, 2, 3, 4) # ==&gt; 2.4</span><br><span class="line">average()</span><br><span class="line"># 报错</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure>
<p>在执行average()的时候，却报错了，这是因为在使用可变参数时，没有考虑周全导致的，因为可变参数的长度可能是0，当长度为0的时候，就会出现除0错误。因此需要添加保护的逻辑，这是同学在使用过程中需要特别注意的。</p>
<h3 id="Python函数使用可变关键字参数"><a href="#Python函数使用可变关键字参数" class="headerlink" title="Python函数使用可变关键字参数"></a>Python函数使用可变关键字参数</h3><p>可变参数在使用上确实方便，函数会把可变参数当作tuple去处理，tuple在使用上有一定的局限性，比如有时候想找到特定位置的参数，只能通过下标的方式去寻找，如果顺序发生变化得时候，下标就会失效，函数逻辑就得重新修改实现。</p>
<p>Python函数提供可变关键字参数，对于可变关键字参数，可以通过关键字的名字key找到对应的参数值，想想这和我们之前学习过的什么类似？是的没错，dict，Python会把可变关键字参数当作dict去处理；对于可变关键字参数，<strong>一般使用</strong>kwargs来表示**。</p>
<p>例如，想要打印一个同学的信息，可以这样处理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def info(**kwargs):</span><br><span class="line">    print(&#x27;name: &#123;&#125;, gender: &#123;&#125;, age: &#123;&#125;&#x27;.format(kwargs.get(&#x27;name&#x27;), kwargs.get(&#x27;gender&#x27;), kwargs.get(&#x27;age&#x27;)))</span><br><span class="line"></span><br><span class="line">info(name = &#x27;Alice&#x27;, gender = &#x27;girl&#x27;, age = 16)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于一个拥有必需参数，默认参数，可变参数，可变关键字参数的函数，定义顺序是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def func(param1, param2, param3 = None, *args, **kwargs):</span><br><span class="line">    print(param1)</span><br><span class="line">    print(param2)</span><br><span class="line">    print(param3)</span><br><span class="line">    print(args)</span><br><span class="line">    print(kwargs)</span><br><span class="line"></span><br><span class="line">func(100, 200, 300, 400, 500, name = &#x27;Alice&#x27;, score = 100)</span><br><span class="line"># ==&gt; 100</span><br><span class="line"># ==&gt; 200</span><br><span class="line"># ==&gt; 300</span><br><span class="line"># ==&gt; (400, 500)</span><br><span class="line"># ==&gt; &#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;score&#x27;: 100&#125;</span><br></pre></td></tr></table></figure>
<p>当然，这么多类型的参数，很容易导致出错，在实际使用上，不建议定义这么多的参数。</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="http://domain.com/awesome.mp3">
            </audio>
            
        </div>
        
    <div id="gitalk-container" class="comment link"
		data-enable="false"
        data-ae="false"
        data-ci=""
        data-cs=""
        data-r=""
        data-o=""
        data-a=""
        data-d="false"
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
